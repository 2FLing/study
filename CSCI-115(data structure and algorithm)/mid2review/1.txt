Linear Search Algorithm:
bubble sort 	O(n^2)
insertion sort theta(n^2)
quick sort theta(nlogn)
merge sort theta(nlogn)

Counting sort:
time complexity O(n+r), r is the range
it is stable and not in place sort
Counting Sort (A,B,r):
	let C[0...r] to be a new array
	for i = 0 to r:
		C[i] = 0
	for j = 1 to A.length
		C[A[i]] = C[A[i]] +1
	for i = 1 to r:
               C[i] = C[i-1] + C[i]
	for j = A.length to 1
		  B[C[A[i]]] = A[i]
		  C[A[i]] = C[A[i]] - 1
	
Radix sort: theta (d(n+k)) d will be the passes and k will be the radix that is choosen
Radix Sort (A,B,d,k):
	let C [0...k] to be a new array
	for i = 0 to d
		for j = 0 to k
			C[i] = 0
		for n = 1 to A.length
			temp = A[i]/ pow(10,i)
			digit = A[i] mod 10
			C[digit] = C[digit]+1
		for j = 1 to k
			C[j] = C[j-1] + C[j]
		for n  = A.length to 1
			temp = A[n]/pow(10,i)
			digit = A[n] mod 10
			B[C[digit]] = A[n]
			C[digit]  = C [digit] - 1
		
radix sort is not inplace sort and it is stable

Max-Min (A):
	max = min = A[1]
	for i = 1 to A.length/2
		if A[2i] > A[2i-1]
			if A[2i] > max
				max = A[2i]
			if A[2i-1] < min
				min = A[2i-1]
		else 
			if A[2i-1] > max
				max = A[2i-1]
			if A[2i] < min
				min  = A[2i]
	return min and max

decision tree:
minimum leaves : n!, maximum leaves: 2 ^h
the tree height is the worst case for comparison
each path is a comparison between input elements

partition (A,low,high):
	 i = high+1
	 pivot = A[low]
	for j = high to low+1
	      if A[j] >= pivot
			i = i - 1
			swap(A[j],A[i]
	swap(A[i-1],A[low])
	return i-1
quick-sort(A,low,high)
	if low<high
		q = partition(A,low,high)
		quick-sort(A,low,q-1)
		quick-sort(A,q+1,high)

For randomized quick sort, no input can elicit worst case
behavior and worst case become less likely.

randomized partition(A,p,r):
	i  = random(p,r)
	swap(A[i],A[p])
	return partition(A,p,r)

partition2(A,low,high):
	j = low-1
	p = A[high]
	for i = low to high-1
		if A[i]<= p
			j = j +1
			swap(A[i],A[j])
	swap(A[j+1],A[high])
	return i+1

worst case for quick sort:
T(n) = T(k) + T(n-k) + O(n)
k = 1, worst case
T(n) <= c*1^2 + c(n-1)^2 + O(n)
T(n) <=  c^2 + cn^2 - 2cn + c^2 + O(n)
T(n) <= 2c^2 +cn^2 - 2cn  + O(n)
T(n) <= cn^2 + 2c^2-2cn
when 2c^2- 2cn > 0 , T(n) <= cn^2
Then c-n >0, when n < c, T(n) <= O(n^2) 

common dynamic adt
stacks queues, trees hash tables...
queue:
FIFO
enqueue:
	q[tail[q]] = x
	if tail[q] = length[q]
		tail[q] = 1
	else
		tail[q] = (tail[q]+1) mod n

dequeue:
	x = q[head[q]]
	if head[q] == length[q]
		head[q] = 1
	else
		head[q] = (head[q]+1) mod n
Stack:
LIFO
push(s,x):
	if top[s] == length[s]:
		error "overflow"
	else
		top[s] = top[s] +1
		top[s] = x
pop(s):
	if top[s] == 0:
		error "underflow"
	else
		top[s] = top[s] -1
	return s[top[s]+1]
empty(s):
	return top[s] == 0
use array to build stack
easy to setup and fast to access
but fixed size and time consuming to do an ordered insert

linked list
can grow finite size, quick to insert or delete
very slow to search or access and more complicate to setup than array

list-search(l,k):
	x = head[l]
	while x!= null and key[x] ! = k
		x = next[x]
	return x
list-insert(l,x):
	next[x] = head[l]
	if head[l] != null
		prev[head[l]] = x
	head[l] = x
	prev[x] = null
list-delete(l,x):
	if prev[l] != null
		next[prev[l]] = next[x]
	else
		head[l] = next[x]
	if next[l] != null
		prev[next[l]] = prev[x]
 HASH TABLE - direct addressing:
size of table : typically 1/5 or 1/10 of the total number of element
load factor: a = n/m n will be the number of element stored in the table
					m will be the number of slots
unsuccessful search T = O(1+a), where 1 is the time complexity for hasing the key
succesful search T = O(1+a/2) = O(1+a)
if m is proportional to n then a = n/m = O(m)/m = O(1)


Tree_Maximum (x): 
	if x.right!= Nil
		return Tree_Maximum(x.right)
	return x;
Tree_Minimum(x):
	if x.left != Nil
		return Tree_Minimum(x.left)
	return x;

TREE-SUSSESOR(x):
	if x.right != Nil
		return Tree_Minimum(x.right)
	else
		y = x.p
		while y != nil and x == y.right
			x = y
			y = y.p
		return y
			
		

TREE-PREDECESSOR(x):
	if x.left != Nil
		return Tree-maximum(x.left)
	else
		y = x.p
		while y != nil and x == y.left
			x = y
			y = y.p
	return y
TREE-INSERT（T，z):	
	y = nil
	x = T.root
	while x!=nil
		y = x
		if x.key < z.key
			x = x.right
		else
			x = x.left
	z.p = y
	if y == nil
		T.root = y
	else if y.key < z.key
		y.right = z
	else
		y.left =z
		
transplant(T,u,v):
	if u.p == Nil
		T.root = v
	else
		if u.p.left == u
			u.p.left = v
		else
			u.p.right = v
	if v != Nil
		v.p = u.p
TREE-DELETE(T,z):
	if z.left == NIL
		transplant(T,z,z.right)
	else if z.right == NIL
		transplant(T,z,z.left)
	else
		y = minimum(z.right)
		if y!= z.right
			transplant(T,y,y.right)
			y.right = z.right
			y.right.p = y
		transplant(T,z,y)
		y.left = z.left
		y.left.p = y
	
LEFT-ROTATE(T,x):
	y = x.right
	x.right = y.left
	if y.left != NIL
		y.left.p = x
	y.p = x.p
	if x.p == NIL
		T.root = y
	else
		if x.p.left == x
			x.p.left = y
		else
			x.p.right = y
	y.left = x
	x.p = y
	
RIGHT-ROTATEE(T,x):
	y  = x.left
	x.left = y.right
	if y.right ! = NIL
		y.right.p = x
	y.p = x.p
	if x.p == NIL
		T.root = y
	else
		if x.p.left == x
			x.p.left =y
		else
			x.p.right =y
	y.right = x
	x.p = y
RB-INSERT(T,z):
	x = T.root
	y = NIL
	while x != NIL
		y = x
		if x.key < z.key
			x = x.right
		else
			x = x.left
	if y == NIL
		T.root = z
	else if y.key < z.key
		y.right = z
	else
		y.left= z
	z.left = NIL
	z.right = NIL
	z.color = red
	z. p = y
	rb-insert-fix-up (T,z)

RB-INSERT-FIXUP(T,z):
	while z.p.color == red
		if z.p == z.p.p.left
			uncle = z.p.p.right
			if uncle.color == red
				z.p.color = black
				uncle.color = black
				z.p.p = red
				z = z.p.p
			else if z = z.p.right
				z = z.p
				left-rotate(T,z)
			z.p.color = black
			z.p.p.color = red
			right-rotate(T,z.p.p)
		else
			uncle = z.p.p.left
			if uncle.color == red
				uncle.color = black
				z.p.color = black
				z.p.p.color = red
				z = z.p.p
			else if z == z.p.left
				z = z.p
				right-rotate(T,z)
			z.p = black
			z.p.p = red
			left-rotate(T,z.p.p)
RB-TRANSPLANT(T,u,v):
	if u.p == NIL
		T.root = v
	else if u.p.left == u
		u.p.left = v
	else
		u.p.right =v
	v.p = u.p
RB-DELETE(T,z):
	original-color = z.color
	if z.left == NIL
		x =z.right
		transplant(T,z,z.right)
	else if z.right == NIL
		x = z.left
		transplant(T,z,z.left)
	else
		y = tree-minimum(z.right)
		x = y.right
		original-color = y.color
		if y!=z.right
			transplant(T,y,y.right)
		y.right = z.right
		y.right.p = y
	y.left = z.left
	y.left.p = y
	y.p = z.p
	if original-color == black
	rb-delete-fixup(T,z)	
RB-DELETE-FIXUP(T,x)

1.each node must be neither black or red
2.root node is always black
3. every leaf(NIL) is black
4. the child of red node must be black
5. for each node, every path from that node to descendant leaves
has the same number of black nodes.

bh = b h = h b>= h/2  n+1>= 2^b >= 2^h
	n+1>= h/2
	h<=2lg(n+1)